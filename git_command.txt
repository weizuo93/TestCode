
						*****************************************************************************	
						*									    *									
						*			          git 命令                                  *
						*									    *
						*****************************************************************************


*************************************************************************************************************************************************************************************************************

       工作目录---------git add--------->暂存区---------git commit--------->本地分支（本地仓库）---------git push--------->远程分支（个人仓库）---------pull request--------->master分支（官方仓库）

*************************************************************************************************************************************************************************************************************

git init                                                                # 在当前目录下创建版本库

git status                                                              # 查看草稿中对哪些文件做了修改，还未添加到暂存区，同时查看暂存区中的哪些文件还没有提交到本地分支

git diff                                                                # 查看草稿中对那些文件做了哪些修改
git diff <文件名>                                                       # 查看草稿中对指定文件做了哪些修改

git add <文件名1> <文件名2> ...                                          # 将文件添加到暂存区
git add -u                                                              # 添加所有文件到暂存区，但是对于未追踪(Untracked)的文件不会被该语句添加到暂存区，只能明确使用文件名进行添加

git commit -m "<本次提交的说明信息>"                                     # 将暂存区的文件提交到本地分支

git push                                                                # 将对本地分支的提交push到远程关联的分支上
git push -u <远程主机名>                                                # 远程创建一个与本地分支同名的远程分支，并将本地的新分支push上去（本地仓库并非关联远程仓库之后的首次push代码，其他本地分支已经push过了）
git push -u <远程主机名> <远程分支名>                                    # 远程创建一个远程分支，并将本地的新分支push上去（本地仓库并非关联远程仓库之后的首次push代码，其他本地分支已经push过了）
git push --set-upstream <远程主机名> <远程分支名>                        # 设置远程分支，并将代码push上去 （本地仓库关联远程仓库之后首次push代码，）
git push --force                                                       # 本地branch版本回退之后，让远程branch也进行版本回退

git checkout -b <本地分支名>                                            # 在本地创建一个分支，并切换到新创建的分支
git checkout <本地分支名>                                               # 切换到另一个本地分支

git branch                                                              #列出所有本地分支（当前的本地分支会用*标识）
git branch -a                                                           # 列出所有本地分支和远程分支（当前的本地分支会用*标识）
git branch -vv                                                          # 查看本地分支与远程分支的关联关系（当前的本地分支会用*标识）
git  branch --set-upstream-to= <远程主机名>/<远程分支名>  <本地分支名>   # 设置本地与远程分支的追踪关系
git branch -d <分支名>                                                  # 删除本地分支
git push origin --delete <远程分支名>                                   # 删除远程分支

git log                                                                # 查看历史提交记录

git reset [--soft | --mixed | --hard] [HEAD]                           # 版本回退
注：“HEAD”表示当前版本，“HEAD^”表示上一个版本，“HEAD^^”表示上上一个版本，以此类推；“HEAD~0”表示当前版本，“HEAD~1”表示上一个版本；“HEAD^2”表示上上一个版本，“HEAD^3”标识上上上一个版本，以此类推。
注：
   参数“--soft”用于将HEAD引用指向给定提交，暂存区和工作目录的内容是不变的，在三个命令中对现有版本库状态改动最小。
   参数“--mixed”为默认，可以省略，用于将HEAD引用指向给定提交，并且暂存区内容也跟着改变，工作目录内容不变；这个命令会将暂存区变成刚刚暂存该提交全部变化时的状态，会显示工作目录中有什么修改。
   参数“--hard”用于将HEAD引用指向给定提交，暂存区和工作目录的内容都会变为给定提交时的状态，也就是在给定提交后所修改的内容都会丢失(新文件会被删除，不在工作目录中的文件恢复，未清除回收站的前提)。
git reset [--soft | --mixed | --hard] [HEAD] <文件名>                  # 回退指定文件到指定版本
git reset HEAD^                                                        # 回退所有内容到上一个版本
git reset HEAD^ <文件名>                                               # 回退特定文件到上一个版本
git push -f                                                            # 回退远程分支版本（本地分支版本回退之后，强制提交到远程分支，远程分支将强制更新到本地分支reset版本）

git remote -vv                                                         # 查看本地仓库与远程仓库的关联关系
git remote add <远程主机名> <远程仓库名>                                # 给本地仓库添加远程仓库关联
git remote remove <远程主机名>                                         # 给本地仓库取消远程仓库关联
git remote show <远程主机名>                                           # 显示远程追踪关系

git config --global user.email "<邮箱>"                                # 配置邮箱
git config --global user.name "<用户名称>"                             # 配置用户名称



撤销对文件的修改
git checkout -- <文件名>   #把文件在工作区的修改全部撤销（一种是文件自修改后还没有被放到暂存区，撤销修改就回到和版本库一模一样的状态；一种是文件已经添加到暂存区后又作了修改，撤销修改就回到添加到暂存区后的状态。总之，就是让文件回到最近一次git commit或git add时的状态。）


同步社区master分支到本地master分支
git fetch upstream
git checkout master       #切换到本地master分支
git merge upstream/master #将社区master分支合并到本地master分支
git push                  #将合并之后的本地master push到本用户的远程master

如果git merge upstream/master不成功，则要使用rebase
git rebase upstream/master


将github master分支的一次特定PR commit合并到gitlab官方仓库上
git clone <gitlab官方仓库>                                    # 从gitlab官方仓库克隆工程
git remote add <github官方远程主机> <github官方仓库>           # 将github官方仓库添加为本地仓库的远程仓库
git checkout -b <本地新分支>                                  # 创建本地新分支
git cherry-pick <github上的commit id>                         # 将github官方仓库的一次提交cherry-pick到本地新创建的分支
如果代码不存在冲突，则针对github官方仓库的特定commit（由commit id标识）将被合并到本地分支；否则需要手动处理冲突，手动处理冲突时，执行
git status                                                    # 查看冲突文件（标注“双方修改”的即为存在冲突的文件）
vim <冲突文件>                                                # 依次打开存在冲突的文件进行冲突处理
...
git add <冲突文件> <冲突文件> ...                              # 添加处理冲突后的文件到暂存区
git cherry-pick --continue                                    # 冲突处理完成之后继续进行cherry-pick操作
  或
git cherry-pick --abort                                       # 取消本次cherry-pick操作
git log                                                       # 查看cherry-pick之后的提交
git remote add <gitlab个人远程主机> <gitlab个人远程仓库>       # 将gitlab个人远程仓库添加为本地仓库的远程仓库
git push <gitlab个人远程主机> <远程分支>                       # 将cherry-pick之后的本地分支push到gitlab个人远程仓库的指定分支
<Pull Request>                                                # 向gitlab官方仓库提交PR，等待代码合并


rebase 操作：
git checkout master                                           # 切换到master分支
git pull                                                      # 将本地master分支更新到远程master分支最近的提交
git checkout <待rebase的分支>                                 # 切换到待rebase的分支
git rebase master                                             # 在当前分支执行rebase（变基）操作
如果代码存在冲突，需要手动处理冲突，执行
git status                                                    # 查看冲突文件（标注“双方修改”的即为存在冲突的文件）
vim <冲突文件>                                                # 依次打开存在冲突的文件进行冲突处理
...
git add <冲突文件> <冲突文件> ...                              # 添加处理冲突后的文件到暂存区
git rebase --continue                                         # 冲突处理完成之后继续进行rebase操作
  或
git rebase --abort                                            # 取消本次rebase操作
如果执行完“git rebase --continue”还不能退出rebase状态，执行“git rebase --skip”跳过当前操作
git push -f                                                   # 强制提交rebase之后的本地分支到远程分支
